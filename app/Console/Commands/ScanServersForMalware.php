<?php
/*
namespace Jexactyl\Console\Commands;

use Jexactyl\Models\Server;
use Jexactyl\Models\User;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Jexactyl\Repositories\Wings\DaemonFileRepository;
use Carbon\Carbon;r

class ScanServersForMalware extends Command
{
    protected $signature = 'servers:scan-malware 
                            {--all : Scan all servers including suspended ones} 
                            {--server= : Scan specific server ID}
                            {--user= : Scan all servers for specific user ID}
                            {--debug : Show detailed debugging information}
                            {--skip-package-json : Skip package.json scanning}
                            {--quick : Quick scan mode - scan only suspicious files}
                            {--force : Force scan even if server is suspended}
                            {--stats : Show scanning statistics only}
                            {--dry-run : Scan but don\'t take any action}
                            {--webhook-test : Test webhook configuration}
                            {--skip-env : Skip scanning .env files completely}
                            {--whitelist : Scan in whitelist mode - only flag known bad patterns}';
    
    protected $description = 'Advanced malware scanner with high precision detection and webhook reporting';

    /**
     * HIGH-CONFIDENCE MALWARE PATTERNS
     * Only patterns that are almost certainly malicious
     */
    private array $patterns = [
        'token_grabber' => [
            'patterns' => [
                // LevelDB access + webhook exfiltration
                '/leveldb[\\/\\\\].*\\.(ldb|log)[^}]*{.*webhook.*send.*https:\\/\\/discord\\.com/si',
                '/Local\\\\ State.*encrypted_key.*decrypt.*webhook/si',
                '/DPAPI.*CryptUnprotectData.*token.*webhook/si',
                
                // Token regex with immediate webhook URL
                '/(?:mfa\\.[A-Za-z0-9_-]{84}|[A-Za-z0-9_-]{24}\\.[A-Za-z0-9_-]{6}\\.[A-Za-z0-9_-]{27}).*https?:\\/\\/discord\\.com\\/api\\/webhooks\\/\\d+\\/[A-Za-z0-9_-]+/si',
                
                // Known malicious grabber code
                '/DiscordTokenProtector.*bypass.*injection/si',
                '/BetterDiscord.*Rdimo.*Hazard.*grabber/si',
                '/injection-obf\\.js.*steal.*password.*webhook/si',
            ],
            'reason' => 'Discord Token Grabber',
            'description' => 'Steals Discord authentication tokens and exfiltrates via webhooks',
            'severity' => 'CRITICAL',
            'suspension_days' => 7,
            'webhook_color' => 0xFF0000,
            'detection_confidence' => 'HIGH'
        ],
        
        'discord_selfbot' => [
            'patterns' => [
                // Selfbot library imports with clear context
                '/require\\(["\']discord\\.js-selfbot-v\\d+["\']\\)[^}]+client\\.login/si',
                '/from ["\']discord-self["\'] import.*Client.*login/si',
                
                // Selfbot configuration
                '/config\\.selfbot.*=.*true.*client\\.login/si',
                '/isSelfbot.*true.*token.*["\'][A-Za-z0-9\\._-]{59,}["\']/si',
                
                // Mass automation tools
                '/massDM\\.js.*function.*send.*\\d+.*users/si',
                '/raidTool\\.startAttack.*function.*spam/si',
                '/autoReact.*every.*message.*function/si',
            ],
            'reason' => 'Discord Selfbot / Automation',
            'description' => 'Automates user accounts violating Discord Terms of Service',
            'severity' => 'HIGH',
            'suspension_days' => 3,
            'webhook_color' => 0xFFA500,
            'detection_confidence' => 'HIGH'
        ],
        
        'crypto_miner' => [
            'patterns' => [
                // XMRig configuration with pool and wallet
                '/xmrig.*--pool.*stratum.*--user.*(?:4[0-9AB][A-Za-z0-9]{93}|0x[a-fA-F0-9]{40})/i',
                '/minerd.*-o.*stratum.*-u.*(?:4[0-9AB][A-Za-z0-9]{93}|0x[a-fA-F0-9]{40})/i',
                
                // Mining configuration files
                '/"url":\\s*"stratum[+]tcp:\\/\\/[^"]+",\\s*"user":\\s*"(?:4[0-9AB][A-Za-z0-9]{93}|0x[a-fA-F0-9]{40})"/si',
                '/"algo":\\s*"(?:rx\\/0|cryptonight|randomx)".*"pool":/si',
                
                // Hidden miner with obfuscation
                '/process\\.name.*=.*["\']svchost["\'].*miner/si',
                '/hideWindow.*true.*startMining.*function/si',
            ],
            'reason' => 'Cryptocurrency Miner',
            'description' => 'Unauthorized cryptocurrency mining consuming server resources',
            'severity' => 'CRITICAL',
            'suspension_days' => 14,
            'webhook_color' => 0x8B0000,
            'detection_confidence' => 'HIGH'
        ],
        
        'ddos_tool' => [
            'patterns' => [
                // DDoS tools with attack commands
                '/LOIC\\.exe.*attack\\.start.*function/si',
                '/slowloris\\.py.*-d.*attack.*-t.*\\d+/si',
                
                // Network flood code
                '/while\\s*\\(?true\\)?\\s*{[^}]*socket\\.send\\([^)]*\\)[^}]*\\d+[^}]*}/si',
                '/flood\\(.*ip.*port.*\\d+.*packets/si',
                
                // Booter panels
                '/booter\\.php.*api_key.*target.*ip/si',
                '/stresser.*panel.*attack.*methods/si',
            ],
            'reason' => 'DDoS Attack Tool',
            'description' => 'Distributed Denial of Service attack tool',
            'severity' => 'CRITICAL',
            'suspension_days' => 30,
            'webhook_color' => 0xDC143C,
            'detection_confidence' => 'HIGH'
        ],
        
        'backdoor' => [
            'patterns' => [
                // Reverse shells
                '/bash.*-i.*>&.*\\/dev\\/tcp\\/.*\\d+.*0>&1/si',
                '/python.*-c.*import.*socket,subprocess.*s\\.connect\\(.*\\)/si',
                
                // PHP backdoors
                '/eval\\(base64_decode\\(\\$_POST\\[[\'"]cmd[\'"]\\]\\)\\)/si',
                '/system\\(\\$_GET\\[[\'"]command[\'"]\\]\\)/si',
                '/shell_exec\\(\\$_REQUEST\\[[\'"]exec[\'"]\\]\\)/si',
                
                // Bind shells
                '/socket\\.listen\\(\\d+\\).*while.*true.*conn.*exec/si',
                '/nc.*-lvp.*\\d+.*-e.*\\/bin\\/bash.*>/dev.*null/si',
            ],
            'reason' => 'Remote Access Tool / Backdoor',
            'description' => 'Provides unauthorized remote access to the server',
            'severity' => 'CRITICAL',
            'suspension_days' => 30,
            'webhook_color' => 0xB22222,
            'detection_confidence' => 'HIGH'
        ],
    ];

    /**
     * WHITELISTED PATTERNS - Things that look suspicious but are often legitimate
     */
    private array $whitelistPatterns = [
        // Common in config files
        '/^[A-Z_][A-Z0-9_]*=.*$/m', // .env style lines
        '/"api_key":\s*".*"/', // API keys in JSON
        '/"token":\s*".*"/', // Tokens in config
        '/0x[a-fA-F0-9]{40}/', // Ethereum addresses (common in web3 apps)
        '/[A-Za-z0-9_-]{24}\.[A-Za-z0-9_-]{6}\.[A-Za-z0-9_-]{27}/', // Discord bot tokens
        '/mongodb\\+srv:\\/\\/[^@]+@[^\\/]+\\/[^\\?]+/', // MongoDB URIs
        '/https?:\\/\\/discord\\.com\\/api\\/webhooks\\/\\d+\\/[A-Za-z0-9_-]+/', // Webhook URLs alone
        
        // Common in Python/Discord bots
        '/DISCORD_TOKEN\\s*=\\s*["\'][^"\']+["\']/',
        '/BOT_TOKEN\\s*=\\s*["\'][^"\']+["\']/',
        '/client\\.run\\(["\'][^"\']+["\']\\)/',
        
        // Database connections
        '/DATABASE_URL=/',
        '/MONGO_URI=/',
        '/REDIS_URL=/',
    ];

    /**
     * EXACT MALICIOUS STRINGS - Only flag these exact matches
     */
    private array $exactMaliciousStrings = [
        // Selfbot libraries
        'discord.js-selfbot-v13',
        'discord.js-selfbot-v14',
        'discord-self-bot',
        'discord.py-self',
        
        // Known malicious packages
        'discord-lofy',
        'discord-stealer',
        'token-logger',
        'hazard-grabber',
        'vvs-stealer',
        
        // Mining software
        'xmrig.exe',
        'minerd.exe',
        'cpuminer.exe',
        
        // DDoS tools
        'LOIC.exe',
        'HOIC.exe',
        'slowloris.py',
        
        // Web shells
        'c99shell.php',
        'r57shell.php',
        'wso.php',
    ];

    /**
     * SUSPICIOUS CONTEXT KEYWORDS - Must be present with patterns
     */
    private array $contextKeywords = [
        'token_grabber' => ['steal', 'grab', 'extract', 'webhook', 'exfiltrate', 'injection'],
        'crypto_miner' => ['stratum', 'pool', 'mining', 'hashrate', 'xmrig', 'minerd'],
        'ddos_tool' => ['flood', 'attack', 'packets', 'syn', 'udp', 'amplification'],
        'backdoor' => ['shell', 'reverse', 'bind', 'exec', 'system', 'eval'],
        'discord_selfbot' => ['selfbot', 'autoReact', 'massDM', 'raidTool', 'spam'],
    ];

    private DaemonFileRepository $fileRepository;
    private array $scanCache = [];
    private int $filesScanned = 0;
    private int $filesSkipped = 0;
    private int $detectionCount = 0;

    public function __construct()
    {
        parent::__construct();
        $this->fileRepository = app(DaemonFileRepository::class);
    }

    public function handle()
    {
        $startTime = microtime(true);
        
        $this->printBanner();
        
        if ($this->option('webhook-test')) {
            $this->testWebhook();
            return Command::SUCCESS;
        }
        
        if ($this->option('stats')) {
            $this->showStatistics();
            return Command::SUCCESS;
        }
        
        // Get servers to scan
        $servers = $this->getServersToScan();
        
        if ($servers->isEmpty()) {
            $this->error('âŒ No servers found to scan!');
            return Command::FAILURE;
        }
        
        $this->info("ðŸ“Š Scanning {$servers->count()} servers...");
        $this->newLine();
        
        $results = [];
        
        foreach ($servers as $server) {
            $serverStart = microtime(true);
            $result = $this->scanSingleServer($server);
            $serverTime = round(microtime(true) - $serverStart, 2);
            
            $results[] = [
                'server' => $server,
                'result' => $result,
                'time' => $serverTime
            ];
        }
        
        $totalTime = round(microtime(true) - $startTime, 2);
        $this->displayResults($results, $totalTime);
        
        // Log scan summary
        $this->logScanSummary($results);
        
        return Command::SUCCESS;
    }
    
    private function printBanner(): void
    {
        $this->info('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        $this->info('â•‘          ðŸ›¡ï¸ NEO DESIGNS MALWARE SCANNER V3.0 ðŸ›¡ï¸          â•‘');
        $this->info('â•‘           High Precision - Low False Positives           â•‘');
        $this->info('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        $this->newLine();
        
        if ($this->option('debug')) {
            $this->warn('ðŸ” DEBUG MODE ENABLED - Showing detailed output');
        }
        
        if ($this->option('quick')) {
            $this->info('âš¡ QUICK SCAN MODE - Scanning only high-confidence files');
        }
        
        if ($this->option('dry-run')) {
            $this->warn('âš ï¸ DRY RUN MODE - No actions will be taken');
        }
        
        if ($this->option('skip-env')) {
            $this->info('ðŸ“ Skipping .env files completely');
        }
        
        if ($this->option('whitelist')) {
            $this->info('âœ… WHITELIST MODE - Only flagging known malicious patterns');
        }
        
        $this->newLine();
    }
    
    private function getServersToScan()
    {
        $query = Server::query();
        
        if ($this->option('server')) {
            return $query->where('id', $this->option('server'))->get();
        }
        
        if ($this->option('user')) {
            return $query->where('owner_id', $this->option('user'))->get();
        }
        
        if ($this->option('all') || $this->option('force')) {
            return $query->get();
        }
        
        return $query->where('suspended', false)->get();
    }
    
    private function scanSingleServer(Server $server): array
    {
        $this->info("ðŸ” Scanning: {$server->name} (ID: {$server->id})");
        
        if ($server->suspended && !$this->option('force')) {
            $this->line("   â¸ï¸  Server is suspended, skipping...");
            return ['status' => 'skipped', 'reason' => 'suspended'];
        }
        
        try {
            $this->fileRepository->setServer($server);
            
            // Clear cache for this server
            unset($this->scanCache[$server->id]);
            
            $result = [
                'status' => 'scanned',
                'detections' => [],
                'stats' => [
                    'files_found' => 0,
                    'files_scanned' => 0,
                    'files_skipped' => 0,
                    'scan_time' => 0,
                ]
            ];
            
            $scanStart = microtime(true);
            
            // Check package.json first (fastest check)
            if (!$this->option('skip-package-json')) {
                $packageResult = $this->scanPackageJson($server);
                if ($packageResult['is_malicious']) {
                    $result['detections'][] = $packageResult;
                    $result['stats']['scan_time'] = round(microtime(true) - $scanStart, 2);
                    return $result;
                }
            }
            
            // Get files to scan (optimized)
            $files = $this->getFilesToScan($server);
            $result['stats']['files_found'] = count($files);
            
            if ($this->option('debug')) {
                $this->line("   ðŸ“ Found {$result['stats']['files_found']} files to scan");
            }
            
            if (empty($files)) {
                $result['stats']['scan_time'] = round(microtime(true) - $scanStart, 2);
                return $result;
            }
            
            // Scan files
            $detection = $this->scanFiles($server, $files);
            if ($detection) {
                $result['detections'][] = $detection;
            }
            
            $result['stats']['files_scanned'] = $this->filesScanned;
            $result['stats']['files_skipped'] = $this->filesSkipped;
            $result['stats']['scan_time'] = round(microtime(true) - $scanStart, 2);
            
            // Update global counters
            $this->filesScanned += $result['stats']['files_scanned'];
            $this->filesSkipped += $result['stats']['files_skipped'];
            $this->detectionCount += count($result['detections']);
            
            return $result;
            
        } catch (\Exception $e) {
            $this->error("   âŒ Error: {$e->getMessage()}");
            Log::error('Malware scan error', [
                'server_id' => $server->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return [
                'status' => 'error',
                'error' => $e->getMessage(),
                'detections' => []
            ];
        }
    }
    
    private function getFilesToScan(Server $server): array
    {
        $cacheKey = "files_{$server->id}";
        
        if (isset($this->scanCache[$cacheKey])) {
            return $this->scanCache[$cacheKey];
        }
        
        $files = [];
        
        try {
            // Always use quick mode for speed
            $files = $this->getQuickFiles();
            
            // Filter and prioritize files
            $files = $this->filterAndPrioritizeFiles($files);
            
            // Cache results
            $this->scanCache[$cacheKey] = $files;
            
        } catch (\Exception $e) {
            if ($this->option('debug')) {
                $this->warn("   âš ï¸  File listing error: {$e->getMessage()}");
            }
        }
        
        return $files;
    }
    
    private function getQuickFiles(): array
    {
        $files = [];
        
        try {
            $rootFiles = $this->fileRepository->getDirectory('/');
            
            foreach ($rootFiles as $file) {
                if (isset($file['directory']) && $file['directory'] === true) {
                    // Skip ALL directories in quick mode
                    continue;
                } else {
                    $files[] = $file;
                }
            }
            
            // Also check specific suspicious directories
            $suspiciousDirs = ['cogs', 'src', 'bot', 'scripts'];
            foreach ($suspiciousDirs as $dir) {
                try {
                    $dirFiles = $this->fileRepository->getDirectory("/{$dir}");
                    foreach ($dirFiles as $file) {
                        if (!isset($file['directory']) || $file['directory'] !== true) {
                            $file['name'] = "{$dir}/{$file['name']}";
                            $files[] = $file;
                        }
                    }
                } catch (\Exception $e) {
                    // Directory doesn't exist
                }
            }
            
        } catch (\Exception $e) {
            // Ignore errors
        }
        
        return $files;
    }
    
    private function filterAndPrioritizeFiles(array $files): array
    {
        $filtered = [];
        
        foreach ($files as $file) {
            $filename = $file['name'];
            $basename = basename($filename);
            
            // Skip .env files if option is set
            if ($this->option('skip-env') && $basename === '.env') {
                $this->filesSkipped++;
                continue;
            }
            
            // Skip system/log files
            if ($this->isSystemFile($basename)) {
                $this->filesSkipped++;
                continue;
            }
            
            // Calculate priority score
            $priority = $this->calculateFilePriority($filename, $basename);
            
            // Only include files with reasonable priority or suspicious names
            if ($priority >= 80 || $this->isHighlySuspiciousFile($basename)) {
                $file['priority'] = $priority;
                $filtered[] = $file;
            } else {
                $this->filesSkipped++;
            }
        }
        
        // Sort by priority (highest first)
        usort($filtered, function($a, $b) {
            return $b['priority'] <=> $a['priority'];
        });
        
        // Limit number of files
        $fileLimit = $this->option('quick') ? 15 : 30;
        if (count($filtered) > $fileLimit) {
            $filtered = array_slice($filtered, 0, $fileLimit);
        }
        
        return $filtered;
    }
    
    private function isSystemFile(string $basename): bool
    {
        // Skip common system/config files that cause false positives
        $systemFiles = [
            '.env', '.gitignore', '.dockerignore', '.env.example',
            'package-lock.json', 'yarn.lock', 'composer.lock',
            'requirements.txt', 'Pipfile', 'Procfile', 'Dockerfile',
            'docker-compose.yml', 'README.md', 'LICENSE',
        ];
        
        if (in_array($basename, $systemFiles)) {
            return true;
        }
        
        // Skip logs and data files
        if (preg_match('/\.(log|txt|md|json|csv|xml)$/i', $basename)) {
            return true;
        }
        
        return false;
    }
    
    private function isHighlySuspiciousFile(string $basename): bool
    {
        $suspiciousNames = [
            'grabber', 'stealer', 'inject', 'logger', 'keylogger',
            'miner', 'xmrig', 'cpuminer', 'ddos', 'attack',
            'backdoor', 'shell', 'rat', 'virus', 'trojan',
            'selfbot', 'raidtool', 'massdm',
        ];
        
        foreach ($suspiciousNames as $name) {
            if (stripos($basename, $name) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    private function calculateFilePriority(string $filename, string $basename): int
    {
        $priority = 0;
        
        // Suspicious filenames get highest priority
        if ($this->isHighlySuspiciousFile($basename)) {
            $priority += 1000;
        }
        
        // Python/JS files (where malware usually is)
        if (preg_match('/\.(py|js|ts|php)$/i', $basename)) {
            $priority += 100;
        }
        
        // Files in suspicious directories
        if (preg_match('/^(cogs|src|bot|scripts)\//', $filename)) {
            $priority += 50;
        }
        
        // Root files
        if (strpos($filename, '/') === false) {
            $priority += 30;
        }
        
        // Small files (scan faster)
        if (isset($file['size']) && $file['size'] < 10240) {
            $priority += 20;
        }
        
        return $priority;
    }
    
    private function scanPackageJson(Server $server): array
    {
        try {
            $content = $this->fileRepository->getContent('package.json', 65536);
            
            if (!$content) {
                return ['is_malicious' => false];
            }
            
            $package = json_decode($content, true);
            
            if (!$package) {
                return ['is_malicious' => false];
            }
            
            // Check for EXACT malicious package names
            $allDeps = array_merge(
                $package['dependencies'] ?? [],
                $package['devDependencies'] ?? []
            );
            
            foreach ($this->exactMaliciousStrings as $badPackage) {
                if (isset($allDeps[$badPackage])) {
                    return [
                        'is_malicious' => true,
                        'type' => 'malicious_package',
                        'reason' => 'Malicious NPM Package',
                        'description' => "Contains banned package: {$badPackage}",
                        'severity' => 'HIGH',
                        'file' => 'package.json',
                        'pattern' => $badPackage,
                        'detection_confidence' => 'HIGH',
                        'webhook_color' => 0xFF4500,
                        'suspension_days' => 3
                    ];
                }
            }
            
        } catch (\Exception $e) {
            // Package.json doesn't exist or can't be read
        }
        
        return ['is_malicious' => false];
    }
    
    private function scanFiles(Server $server, array $files): ?array
    {
        $fileLimit = $this->option('quick') ? 10 : 20;
        $scannedCount = 0;
        
        foreach ($files as $file) {
            if ($scannedCount >= $fileLimit) {
                if ($this->option('debug')) {
                    $this->line("   âš ï¸  Reached file limit ({$fileLimit}), stopping scan");
                }
                break;
            }
            
            $detection = $this->scanSingleFile($server, $file);
            if ($detection) {
                return $detection;
            }
            
            $scannedCount++;
            $this->filesScanned++;
        }
        
        return null;
    }
    
    private function scanSingleFile(Server $server, array $file): ?array
    {
        $filename = $file['name'];
        
        if ($this->option('debug')) {
            $this->line("   ðŸ“„ Scanning: {$filename}");
        }
        
        try {
            // Read file content with size limit
            $content = $this->fileRepository->getContent($filename, 131072); // 128KB limit
            
            if (empty($content) || strlen($content) > 131072) {
                $this->filesSkipped++;
                return null;
            }
            
            // Skip binary files
            if ($this->isBinaryContent($content)) {
                $this->filesSkipped++;
                return null;
            }
            
            // Check for exact malicious strings first (highest confidence)
            foreach ($this->exactMaliciousStrings as $maliciousString) {
                if (strpos($content, $maliciousString) !== false) {
                    return $this->createExactMatchDetection($maliciousString, $filename, $content);
                }
            }
            
            // Skip whitelisted patterns in whitelist mode
            if ($this->option('whitelist')) {
                foreach ($this->whitelistPatterns as $pattern) {
                    if (preg_match($pattern, $content)) {
                        if ($this->option('debug')) {
                            $this->line("   âœ… Whitelisted pattern found, skipping further checks");
                        }
                        return null;
                    }
                }
            }
            
            // Scan for high-confidence patterns with context validation
            foreach ($this->patterns as $malwareType => $config) {
                foreach ($config['patterns'] as $pattern) {
                    if (@preg_match($pattern, $content)) {
                        // STRICT context validation
                        if (!$this->validateWithContext($malwareType, $content, $pattern)) {
                            if ($this->option('debug')) {
                                $this->line("   âŒ Pattern matched but failed context validation");
                            }
                            continue;
                        }
                        
                        return $this->createDetectionResult($malwareType, $config, $filename, $pattern, $content);
                    }
                }
            }
            
        } catch (\Exception $e) {
            if ($this->option('debug')) {
                $this->warn("   âš ï¸  Error reading {$filename}: {$e->getMessage()}");
            }
            $this->filesSkipped++;
        }
        
        return null;
    }
    
    private function isBinaryContent(string $content): bool
    {
        if (empty($content)) {
            return false;
        }
        
        // Check for null bytes
        if (strpos($content, "\0") !== false) {
            return true;
        }
        
        return false;
    }
    
    private function validateWithContext(string $malwareType, string $content, string $pattern): bool
    {
        // Get context keywords for this malware type
        $keywords = $this->contextKeywords[$malwareType] ?? [];
        
        // If no keywords required, just pass
        if (empty($keywords)) {
            return true;
        }
        
        // Check if at least one context keyword is present
        foreach ($keywords as $keyword) {
            if (stripos($content, $keyword) !== false) {
                return true;
            }
        }
        
        // Check for exact malicious strings as alternative context
        foreach ($this->exactMaliciousStrings as $maliciousString) {
            if (strpos($content, $maliciousString) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    private function createExactMatchDetection(string $maliciousString, string $filename, string $content): array
    {
        // Determine malware type from string
        $malwareType = $this->determineMalwareTypeFromString($maliciousString);
        $config = $this->patterns[$malwareType] ?? $this->patterns['crypto_miner'];
        
        return [
            'is_malicious' => true,
            'type' => $malwareType,
            'reason' => $config['reason'],
            'description' => "Contains exact malicious string: {$maliciousString}",
            'severity' => $config['severity'],
            'file' => $filename,
            'pattern' => 'exact_match:' . $maliciousString,
            'detection_confidence' => 'VERY_HIGH',
            'webhook_color' => $config['webhook_color'] ?? 0xFF0000,
            'suspension_days' => $config['suspension_days'] ?? 7,
            'additional_info' => [
                'webhook_url' => $this->extractWebhookUrl($content),
                'has_token' => !empty($this->extractToken($content)),
                'file_size' => strlen($content),
                'lines' => substr_count($content, "\n") + 1,
            ]
        ];
    }
    
    private function determineMalwareTypeFromString(string $string): string
    {
        if (str_contains($string, 'selfbot')) return 'discord_selfbot';
        if (str_contains($string, 'grabber') || str_contains($string, 'stealer')) return 'token_grabber';
        if (str_contains($string, 'xmrig') || str_contains($string, 'miner')) return 'crypto_miner';
        if (str_contains($string, 'LOIC') || str_contains($string, 'slowloris')) return 'ddos_tool';
        if (str_contains($string, 'shell')) return 'backdoor';
        
        return 'crypto_miner'; // Default
    }
    
    private function createDetectionResult(string $malwareType, array $config, string $filename, string $pattern, string $content): array
    {
        // Extract additional info
        $webhookUrl = $this->extractWebhookUrl($content);
        $token = $this->extractToken($content);
        
        return [
            'is_malicious' => true,
            'type' => $malwareType,
            'reason' => $config['reason'],
            'description' => $config['description'],
            'severity' => $config['severity'],
            'file' => $filename,
            'pattern' => $pattern,
            'detection_confidence' => $config['detection_confidence'] ?? 'HIGH',
            'webhook_color' => $config['webhook_color'] ?? 0xFF0000,
            'suspension_days' => $config['suspension_days'] ?? 7,
            'additional_info' => [
                'webhook_url' => $webhookUrl,
                'has_token' => !empty($token),
                'file_size' => strlen($content),
                'lines' => substr_count($content, "\n") + 1,
            ]
        ];
    }
    
    private function extractWebhookUrl(string $content): ?string
    {
        if (preg_match('/https:\/\/discord\.com\/api\/webhooks\/\d+\/[A-Za-z0-9_-]+/i', $content, $matches)) {
            return $matches[0];
        }
        
        return null;
    }
    
    private function extractToken(string $content): ?string
    {
        if (preg_match('/(mfa\.[A-Za-z0-9_-]{84}|[A-Za-z0-9_-]{24}\.[A-Za-z0-9_-]{6}\.[A-Za-z0-9_-]{27})/i', $content, $matches)) {
            // Return masked token for safety
            $token = $matches[1];
            return substr($token, 0, 10) . '...' . substr($token, -10);
        }
        
        return null;
    }
    
    private function displayResults(array $results, float $totalTime): void
    {
        $this->newLine();
        $this->info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        $totalServers = count($results);
        $infectedServers = 0;
        $totalDetections = 0;
        
        foreach ($results as $result) {
            if (!empty($result['result']['detections'])) {
                $infectedServers++;
                $totalDetections += count($result['result']['detections']);
            }
        }
        
        $this->info("ðŸ“Š SCAN SUMMARY");
        $this->info("  Total servers: {$totalServers}");
        $this->info("  Infected servers: {$infectedServers}");
        $this->info("  Total detections: {$totalDetections}");
        $this->info("  Files scanned: {$this->filesScanned}");
        $this->info("  Files skipped: {$this->filesSkipped}");
        $this->info("  Total time: {$totalTime}s");
        
        if ($infectedServers > 0) {
            $this->newLine();
            $this->warn("âš ï¸  INFECTED SERVERS:");
            
            foreach ($results as $result) {
                if (!empty($result['result']['detections'])) {
                    $server = $result['server'];
                    
                    foreach ($result['result']['detections'] as $detection) {
                        $this->warn("   â€¢ {$server->name} (ID: {$server->id})");
                        $this->warn("     Type: {$detection['reason']}");
                        $this->warn("     Severity: {$detection['severity']}");
                        $this->warn("     File: {$detection['file']}");
                        $this->warn("     Confidence: {$detection['detection_confidence']}");
                        
                        if (isset($detection['additional_info']['webhook_url'])) {
                            $this->warn("     Webhook: " . $detection['additional_info']['webhook_url']);
                        }
                        
                        // Take action if not dry run
                        if (!$this->option('dry-run')) {
                            $this->takeAction($server, $detection);
                        }
                        
                        $this->newLine();
                    }
                }
            }
        }
        
        $this->info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    }
    
    private function takeAction(Server $server, array $detection): void
    {
        if ($this->option('dry-run')) {
            $this->warn("   âš ï¸  DRY RUN: Would suspend for {$detection['suspension_days']} days");
            return;
        }
        
        // Suspend server
        $suspensionDays = $detection['suspension_days'] ?? 7;
        $suspensionEnd = now()->addDays($suspensionDays);
        
        $server->update([
            'suspended' => true,
            'suspension_reason' => "Malware detected: {$detection['reason']}",
            'suspension_ends_at' => $suspensionEnd,
        ]);
        
        // Log suspension
        $this->logSuspension($server, $detection, $suspensionEnd);
        
        // Send webhook notification
        $this->sendDiscordWebhook($server, $detection, $suspensionEnd);
        
        $this->info("   âœ… Server suspended until {$suspensionEnd->format('Y-m-d H:i:s')}");
    }
    
    private function logSuspension(Server $server, array $detection, Carbon $suspensionEnd): void
    {
        $logData = [
            'server_id' => $server->id,
            'server_name' => $server->name,
            'owner_id' => $server->owner_id,
            'detection_time' => now()->toIso8601String(),
            'malware_type' => $detection['type'],
            'reason' => $detection['reason'],
            'severity' => $detection['severity'],
            'detected_file' => $detection['file'],
            'pattern' => $detection['pattern'],
            'suspension_ends_at' => $suspensionEnd->toIso8601String(),
            'detection_confidence' => $detection['detection_confidence'] ?? 'HIGH',
            'additional_info' => $detection['additional_info'] ?? [],
        ];
        
        $logFile = storage_path('logs/malware_detections.json');
        
        $existingLogs = [];
        if (file_exists($logFile)) {
            $existingLogs = json_decode(file_get_contents($logFile), true) ?? [];
        }
        
        $existingLogs[] = $logData;
        
        file_put_contents($logFile, json_encode($existingLogs, JSON_PRETTY_PRINT));
        
        // Also log to Laravel log
        Log::warning('Malware detection - server suspended', $logData);
    }
    
    private function sendDiscordWebhook(Server $server, array $detection, Carbon $suspensionEnd): void
    {
        $webhookUrl = config('malware_scanner.discord_webhook_url');
        
        if (!$webhookUrl) {
            return;
        }
        
        // Get server owner
        $owner = User::find($server->owner_id);
        
        // Severity emojis
        $severityEmojis = [
            'CRITICAL' => 'ðŸ”´',
            'HIGH' => 'ðŸŸ ',
            'MEDIUM' => 'ðŸŸ¡',
            'LOW' => 'ðŸŸ¢'
        ];
        
        $severityEmoji = $severityEmojis[$detection['severity']] ?? 'âšª';
        
        $embed = [
            'username' => "NeoDesigns Malicious Server Scanner",
            'avatar_url' => 'https://cdn.neodesigns.studio/logo/neo.png',
            'embeds' => [
                [
                    'title' => "{$severityEmoji} SERVER SUSPENDED - Malware Detected",
                    'color' => $detection['webhook_color'] ?? 0xFF0000,
                    'description' => "A server has been suspended due to malware detection.",
                    'fields' => [
                        [
                            'name' => 'Server Information',
                            'value' => "**Name:** {$server->name}\n**ID:** `{$server->id}`\n**Owner:** " . ($owner ? $owner->email : 'Unknown'),
                            'inline' => false
                        ],
                        [
                            'name' => 'Detection Details',
                            'value' => "**Type:** {$detection['reason']}\n**Severity:** {$detection['severity']}\n**Confidence:** {$detection['detection_confidence']}",
                            'inline' => true
                        ],
                        [
                            'name' => 'File Details',
                            'value' => "**File:** `{$detection['file']}`\n**Description:** {$detection['description']}",
                            'inline' => true
                        ],
                        [
                            'name' => 'Suspension',
                            'value' => "**Ends:** {$suspensionEnd->format('Y-m-d H:i:s')}\n**Duration:** " . $detection['suspension_days'] . " days",
                            'inline' => true
                        ]
                    ],
                    'footer' => [
                        'text' => 'NeoDesigns Malicious Server Scanner â€¢ High Precision Detection',
                        'icon_url' => 'https://cdn.neodesigns.studio/logo/neo.png'
                    ],
                    'timestamp' => now()->toIso8601String(),
                    'thumbnail' => [
                        'url' => 'https://cdn.neodesigns.studio/logo/neo.png'
                    ]
                ]
            ]
        ];
        
        // Add webhook URL if found (in a masked way)
        if (isset($detection['additional_info']['webhook_url'])) {
            $webhookUrlMasked = $this->maskWebhookUrl($detection['additional_info']['webhook_url']);
            $embed['embeds'][0]['fields'][] = [
                'name' => 'ðŸ”— Webhook Found',
                'value' => "`{$webhookUrlMasked}`",
                'inline' => false
            ];
        }
        
        try {
            Http::timeout(10)
                ->retry(2, 1000)
                ->post($webhookUrl, $embed);
                
        } catch (\Exception $e) {
            Log::error('Failed to send Discord webhook', [
                'error' => $e->getMessage(),
                'server_id' => $server->id
            ]);
        }
    }
    
    private function maskWebhookUrl(string $url): string
    {
        // Mask webhook URL for security
        $parts = explode('/', $url);
        if (count($parts) >= 8) {
            $parts[6] = substr($parts[6], 0, 4) . '...' . substr($parts[6], -4);
            $parts[7] = substr($parts[7], 0, 4) . '...' . substr($parts[7], -4);
        }
        return implode('/', $parts);
    }
    
    private function testWebhook(): void
    {
        $this->info('ðŸ”— Testing Discord webhook configuration...');
        
        $webhookUrl = config('malware_scanner.discord_webhook_url');
        
        if (!$webhookUrl) {
            $this->error('âŒ Webhook URL not configured in .env file!');
            $this->line('Add to your .env file: MALWARE_SCANNER_DISCORD_WEBHOOK_URL=your_webhook_url');
            return;
        }
        
        $testEmbed = [
            'username' => "NeoDesigns Malicious Server Scanner",
            'avatar_url' => 'https://cdn.neodesigns.studio/logo/neo.png',
            'embeds' => [
                [
                    'title' => 'Webhook Test Successful',
                    'description' => 'The malware scanner webhook is configured correctly.',
                    'color' => 0x00FF00,
                    'fields' => [
                        ['name' => 'Status', 'value' => 'Operational', 'inline' => true],
                    ],
                    'footer' => [
                        'text' => 'NeoDesigns Malicious Server Scanner â€¢ High Precision Detection',
                        'icon_url' => 'https://cdn.neodesigns.studio/logo/neo.png'
                    ],
                    'timestamp' => now()->toIso8601String(),
                    'thumbnail' => [
                        'url' => 'https://cdn.neodesigns.studio/logo/neo.png'
                    ]
                ]
            ]
        ];
        
        try {
            $response = Http::timeout(10)->post($webhookUrl, $testEmbed);
            
            if ($response->successful()) {
                $this->info('âœ… Webhook test successful! Check your Discord channel.');
            } else {
                $this->error("âŒ Webhook failed with status: {$response->status()}");
                $this->line('Response: ' . $response->body());
            }
        } catch (\Exception $e) {
            $this->error("âŒ Webhook test failed: {$e->getMessage()}");
        }
    }
    
    private function showStatistics(): void
    {
        $logFile = storage_path('logs/malware_detections.json');
        
        if (!file_exists($logFile)) {
            $this->info('No scan statistics available yet.');
            return;
        }
        
        $logs = json_decode(file_get_contents($logFile), true) ?? [];
        
        $this->info('ðŸ“ˆ MALWARE SCAN STATISTICS');
        $this->info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        $totalDetections = count($logs);
        $severityCounts = [];
        $typeCounts = [];
        
        foreach ($logs as $log) {
            $severity = $log['severity'] ?? 'UNKNOWN';
            $type = $log['malware_type'] ?? 'UNKNOWN';
            
            $severityCounts[$severity] = ($severityCounts[$severity] ?? 0) + 1;
            $typeCounts[$type] = ($typeCounts[$type] ?? 0) + 1;
        }
        
        $this->info("Total detections: {$totalDetections}");
        $this->newLine();
        
        $this->info("By Severity:");
        foreach ($severityCounts as $severity => $count) {
            $this->line("  {$severity}: {$count}");
        }
        
        $this->newLine();
        
        $this->info("By Type:");
        foreach ($typeCounts as $type => $count) {
            $this->line("  {$type}: {$count}");
        }
        
        // Show recent detections
        if ($totalDetections > 0) {
            $this->newLine();
            $this->info("Recent Detections (last 5):");
            
            $recent = array_slice($logs, -5);
            foreach ($recent as $log) {
                $time = Carbon::parse($log['detection_time'])->diffForHumans();
                $this->line("  â€¢ {$log['server_name']} - {$log['reason']} ({$time})");
            }
        }
    }
    
    private function logScanSummary(array $results): void
    {
        $summary = [
            'scan_time' => now()->toIso8601String(),
            'total_servers' => count($results),
            'infected_servers' => 0,
            'total_detections' => 0,
            'total_files_scanned' => $this->filesScanned,
            'total_files_skipped' => $this->filesSkipped,
            'scan_mode' => $this->option('quick') ? 'quick' : 'full',
            'dry_run' => $this->option('dry-run'),
            'skip_env' => $this->option('skip-env'),
            'whitelist_mode' => $this->option('whitelist'),
        ];
        
        foreach ($results as $result) {
            if (!empty($result['result']['detections'])) {
                $summary['infected_servers']++;
                $summary['total_detections'] += count($result['result']['detections']);
            }
        }
        
        Log::info('Malware scan completed', $summary);
    }
}
